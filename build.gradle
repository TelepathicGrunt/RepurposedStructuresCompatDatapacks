import groovy.json.JsonOutput
import groovy.json.JsonSlurper
import groovy.json.StringEscapeUtils

import java.net.http.HttpClient
import java.net.http.HttpRequest
import java.net.http.HttpResponse

plugins {
    id "me.modmuss50.mod-publish-plugin" version "0.4.5"
}

Map<String, String> env = System.getenv()
JsonSlurper slurper = new JsonSlurper()

subprojects {

    // UPLOADING SECTION

    apply plugin: "me.modmuss50.mod-publish-plugin"

    tasks.register('createJar', Zip) {
        outputs.upToDateWhen { false }

        from "$projectDir/src"
        archiveFileName = "${project.mod_id}_v${project.mod_version}.jar"
        destinationDirectory = file("$projectDir/built")

        filesMatching(['META-INF/mods.toml', 'fabric.mod.json', 'pack.mcmeta']) {
            filter {
                it.replace("\${mod_id}", "${project.mod_id}")
                    .replace("\${mod_dependency_name}", "${project.mod_dependency_name}")
                    .replace("\${mod_dependency_mod_id}", "${project.mod_dependency_mod_id}")
                    .replace("\${mod_authors}", "${project.mod_authors}")
                    .replace("\${mod_license}", "${project.mod_license}")
                    .replace("\${mod_version}", "${project.mod_version}")
                    .replace("\${minecraft_version}", "${project.minecraft_version}")
            }
        }
    }

    tasks.register('buildAndRelease') {}
    tasks.publishMods.mustRunAfter tasks.createJar
    tasks.buildAndRelease.dependsOn(tasks.publishMods)

    afterEvaluate {
        project.version = project.mod_version

        Map<String, String> projectUploadLocationsParsed = slurper.parseText(project.project_upload_locations) as Map<String, String>
        Map<String, List<String>> neoforgeDependenciesParsed = slurper.parseText(project.neoforge_dependencies) as Map<String, List<String>>
        Map<String, List<String>> fabricDependenciesParsed = slurper.parseText(project.fabric_dependencies) as Map<String, List<String>>
        List<String> loadersParsed = slurper.parseText(project.loaders) as List<String>
        List<String> supportedMinecraftVersionsParsed = slurper.parseText(project.supported_minecraft_versions) as List<String>

        if (projectUploadLocationsParsed != null && loadersParsed != null) {

            File changeLog = rootProject.file("CHANGELOG.md")
            String changeLogText = changeLog.exists() ? changeLog.text : ""

            publishMods {
                file = tasks.createJar.archiveFile

                displayName  = "Repurposed Structures - ${project.mod_dependency_name} Compat"
                type = STABLE

                changelog = changeLogText
                loadersParsed.each { loader ->
                    modLoaders.add(loader)
                }

                if (env.CURSEFORGEKEY) {
                    curseforge {
                        accessToken = env.CURSEFORGEKEY

                        projectId = projectUploadLocationsParsed["CurseForge"]
                        supportedMinecraftVersionsParsed.each { supportedMinecraftVersion ->
                            minecraftVersions.add(supportedMinecraftVersion)
                        }

                        ArrayList<String> combinedRequiredDeps = new ArrayList<>()

                        if (loadersParsed.contains("neoforge")) {
                            combinedRequiredDeps.addAll(neoforgeDependenciesParsed["CurseForge"])
                        }
                        if (loadersParsed.contains("fabric")) {
                            combinedRequiredDeps.addAll(fabricDependenciesParsed["CurseForge"])
                        }

                        if (loadersParsed.size() > 1) {
                            optional(combinedRequiredDeps.toArray(String[]::new))
                        }
                        else {
                            requires(combinedRequiredDeps.toArray(String[]::new))
                        }
                    }
                }

                if (env.MODRINTH) {
                    modrinth {
                        accessToken = env.MODRINTH_TOKEN

                        projectId = projectUploadLocationsParsed["Modrinth"]
                        supportedMinecraftVersionsParsed.each { supportedMinecraftVersion ->
                            minecraftVersions.add(supportedMinecraftVersion)
                        }

                        ArrayList<String> combinedRequiredDeps = new ArrayList<>()

                        if (loadersParsed.contains("neoforge")) {
                            combinedRequiredDeps.addAll(neoforgeDependenciesParsed["Modrinth"])
                        }
                        if (loadersParsed.contains("fabric")) {
                            combinedRequiredDeps.addAll(fabricDependenciesParsed["Modrinth"])
                        }

                        if (loadersParsed.size() > 1) {
                            optional(combinedRequiredDeps.toArray(String[]::new))
                        }
                        else {
                            requires(combinedRequiredDeps.toArray(String[]::new))
                        }
                    }
                }
            }
        }
    }

    // UPDATING PUBLISHED VERSIONS SECTION

    tasks.register('updateExistingVersioning') {
        String MR_PATCH_ENDPOINT = "https://api.modrinth.com/v2/version/%s"
        String CF_POST_ENDPOINT = "https://minecraft.curseforge.com/api/projects/%s/update-file"
        String CF_GAME_VERSION_TYPES_ENDPOINT = "https://minecraft.curseforge.com/api/game/version-types?cache=true"
        String CF_GAME_VERSIONS_ENDPOINT = "https://minecraft.curseforge.com/api/game/versions?cache=true"
        List<String> supportedMinecraftVersionsParsed = slurper.parseText(project.supported_minecraft_versions) as List<String>

        HttpClient httpClient = HttpClient.newBuilder().version(HttpClient.Version.HTTP_2).build()

        // Construct the IDs for Minecraft Versions that Curseforge requires. Requires two endpoint's data because why the hell not Curseforge.
        HttpRequest cfVersionTypesRequest = HttpRequest.newBuilder()
                .uri(new URI(CF_GAME_VERSION_TYPES_ENDPOINT))
                .header("X-Api-Token", env.CURSEFORGEKEY)
                .GET()
                .build()
        HttpResponse<String> cfVersionTypesRawResponse = httpClient.send(cfVersionTypesRequest, HttpResponse.BodyHandlers.ofString())
        println "CurseForge Version Types Status Code Response: ${cfVersionTypesRawResponse.statusCode()}"
        String cfVersionTypesResponse = cfVersionTypesRawResponse.body()

        HttpRequest cfVersionsRequest = HttpRequest.newBuilder()
                .uri(new URI(CF_GAME_VERSIONS_ENDPOINT))
                .header("X-Api-Token", env.CURSEFORGEKEY)
                .GET()
                .build()
        HttpResponse<String> cfVersionsRawResponse = httpClient.send(cfVersionsRequest, HttpResponse.BodyHandlers.ofString())
        println "CurseForge Versions Status Code Response: ${cfVersionsRawResponse.statusCode()}\r\n"
        String cfVersionsResponse = cfVersionsRawResponse.body()

        List<Map<String, String>> curseForgeVersionTypes = slurper.parseText(cfVersionTypesResponse) as List<Map<String, String>>
        List<Map<String, String>> curseForgeVersions = slurper.parseText(cfVersionsResponse) as List<Map<String, String>>

        Map<String, String> CFMcVersionsToIds = [:]
        List<Map<String, String>> CfMcVersions = curseForgeVersions.findAll { gv ->
            curseForgeVersionTypes.any { gvt ->
                gv['gameVersionTypeID'] == gvt['id']
            }
        }
        for (McGameVersion in CfMcVersions) {
            CFMcVersionsToIds[McGameVersion['name']] = McGameVersion['id']
        }

        println "${CFMcVersionsToIds.size()} Minecraft Versions found from CurseForge\r\n"


        // Update CurseForge file versions

        String curseforgeProjectId = project.cf_project_id
        Integer curseforgeFileId = project.latest_cf_file as Integer
        String cfData = JsonOutput.toJson([
            "fileID": curseforgeFileId,
            "gameVersions": supportedMinecraftVersionsParsed.collect{ CFMcVersionsToIds[it]}
        ])

        String boundary =  "*****"
        HttpRequest curseforgeVersionUpdateRequest = HttpRequest.newBuilder()
                .uri(new URI(CF_POST_ENDPOINT.replace("%s", curseforgeProjectId)))
                .header("Content-Type", "multipart/form-data; boundary=" + boundary)
                .header("X-Api-Token", env.CURSEFORGEKEY)
                .POST(HttpRequest.BodyPublishers.ofByteArray(
                    (
                        "--${boundary}\r\n" +
                        "Content-Disposition: form-data; name=\"metadata\"\r\n" +
                        "\r\n" +
                        "${cfData}\r\n" +
                        "--${boundary}--\r\n"
                    ).getBytes()
                ))
                .build()
        HttpResponse<Object> curseforgeVersionUpdateRawResponse = httpClient.send(curseforgeVersionUpdateRequest, HttpResponse.BodyHandlers.ofString())
        println "Curseforge Version Update Response: ${curseforgeVersionUpdateRawResponse.toString()}"


        // Update Modrinth file versions

        String modrinthFileId = project.latest_mr_file
        String mrData = JsonOutput.toJson([
            "game_versions": supportedMinecraftVersionsParsed.toArray(String[]::new)
        ])

        HttpRequest modrinthVersionUpdateRequest = HttpRequest.newBuilder()
                .uri(new URI(MR_PATCH_ENDPOINT.replace("%s", modrinthFileId)))
                .header("Content-Type", "application/json")
                .header("Authorization", env.MODRINTH_TOKEN)
                .method("PATCH", HttpRequest.BodyPublishers.ofString(mrData))
                .build()
        HttpResponse<Object> modrinthVersionUpdateRawResponse = httpClient.send(modrinthVersionUpdateRequest, HttpResponse.BodyHandlers.ofString())
        println "Modrinth Version Update Response: ${modrinthVersionUpdateRawResponse.toString()}\r\n"
    }
}